---
title: "関数の種類"
date: "2021-08-20T17:59:08Z"
updateDate: ""
category: "javascript"
tags: "javascript"
description: "まだ書いていません"
emoji: "🙂"
topImage: ""
---

# はじめになぜこのような技術が生まれたのかから考えるとキャッチアップしやすい

- JavaScript は知識の連鎖が多い、特に関数絡み
- それぞれの関数の役割をきちんと理解できれば良さそう
- 関数には以下に記すが、結構深いので注意
- まずは外枠をこの記事でまとめ、更に理解が必要なモノがあれば別途記事作成する

# 自分が理解できたドキュメントが必ず存在するから

# 関数宣言

# 関数式

- 関数式とは関数を値として変数の中に入れたもの
- 関数宣言との機能的な違い
  - 巻き上げの有無
  - 名前をつけた場合のスコープの違い

# 匿名関数

- 名前がなくても関数として動かすことができる関数
- コールバック関数に使用されることが多い

# コールバック関数

- コールバック関数とは高階関数に引数として渡された関数のこと
  - 匿名関数になることが多い
  - JavaScript 界隈で「コールバック関数」といえば、非同期処理に関する記事が多く見受けられる
- 代表的なコールバック関数
  - コールバック関数は自分で実装する関数の為なし
- 関連のある関数
  - forEach()
  - addeventListener()
  - setTimeout()
- ユースケース
- まとめ

# 高階関数

- 高階関数とは
  - 関数を引数に取る関数、コールバック関数を受け取っている関数
  - 関数を返す関数
  - 関数を引数に取り、関数を返す関数
- 代表的な高階関数
  - forEach()
  - map()
  - filter()
  - sort()
  - reduce()
- 関連のある関数
  - 今んとこなし
- 構文
  - function 高階関数（コールバック関数）{
    //　処理
    コールバック関数（）；
    }
- 高階関数を使うメリット
  - 関数が増えていった場合の記述量が減る
  - それぞれの関数がコンパクトになり、役割が明確になる
  - 後々、処理が変わる場合に変更する箇所が 1 箇所で済む
  - 処理の責務と処理呼び出しの責務と処理結果の扱いの責務を分離したいときに短く書ける
- ユースケース
  - 引数の関数に一部処理を委譲することで、アルゴリズムを抽象化（共通化）できる
  - 関数を作りたい
    - 状態を持った関数（クロージャー）を作りたい
    - カリー化したい
    - 定型的な関数を楽に作りたい
- つまづきやすい点
  - 高階関数のコールバック関数が匿名関数になっていて、その匿名関数が引数を持つと理解が進まない
- つまづきを解消するコツ
  - ひとつひとつの関数を整理する
  - ひとつひとつの関数を分解する
- まとめ
  - 高階関数は「関数を引数、戻り値として扱う関数」のこと
  - 高階関数は callback 関数への要素の渡し方を担当
  - callback 関数が処理方法を担当
- 参考サイト →https://qiita.com/cocoabreak/items/e0caad052ef84e633bee

#　再帰関数

- 再帰関数とは関数  の中から自分自身を再帰的に呼び出す関数のこと
  - ループで書かれたコードの多くは再帰関数を使って書き直すことができ、コードが簡潔になる
- 代表的な再帰関数
  - 再帰関数は自分で実装する関数の為なし
- 関連のある関数
  - setTimeout()
- ユースケース
  - 簡単なカウントダウンを実装する
  - 同期バージョン
  ```js
  const countdown = (value, fn) => {
    fn(value)
    return value > 0 ? countdownn(value - 1, fn) : value
  }
  countdown(10, value => console.log(value))
  ```
  - 非同期バージョン(delay で非同期実装)
  ```js
  const countdown = (value, fn, delay = 1000) => {
    fn(value)
    return value > 0
      ? setTimeout(() => countdown(value - 1, fn, delay), delay)
      : value
  }
  const log = value => console.log(value)
  countdown(10, log)
  ```
- まとめ
  - 参考サイト →https://qiita.com/jumpyoshim/items/20e6b5e70efa466699b4

# 即時関数

- 即時関数とは関数を定義すると同時に実行するための関数
- グローバルスコープを汚染せずに実行する方法のひとつ
- 一回だけしか必要ない処理をする為に使われる
  - ページが読み込まれた時の初期化処理
  - オブジェクトの生成
  - DOM 要素へのイベントハンドラの設定
- おまじないのように書かれていることも多い

# 今回の目的　達成したい箇所 ユースケース

# 問題　理解できていない箇所

# 解決策　対策手順の概要

# 前提条件　あれば書く　基本情報や必須条件など

# 目的達成手順　順序立てた目的達成手順

# まとめ　ポジティブ意見

# 自分がわからないと意味がないので自分の言葉でアウトプットすること

---

## 構成２　内向けの場合

1. 記事構成（記事構成）
2. 目的（解決したい問題）結論から宣言する
3. 解決策（対策手順の概要）
4. ユースケースのイメージ（ストーリーこれ ② かも）
5. 説明と理由（手順を段階的に）（理由を書くとイメージがさらに UP する）（関連記事へのリンク＝自分用、関連記事への後記＝稼ぎ用）
6. 実習（コード挿入）
7. まとめ　まとめるならポジティブ　まとめないケースもあるマナブさん
8. 稼ぐ要素を必ず添付
9. 応用リンク（⑤ の説明の後記）

---

## ひとつひとつ理解するための大義、フレームワーク

1. 目的と issue 本当に達成すべきか
2. 問題と改善 どのような問題を解決してくれるか
3. 基本の使い方 基本的な使い方だけ書く
4. 応用の使い方 応用して使うにはどのような知識を持っておけば良いかだけ書く
   ※前提として 1,2 のみで大枠だけ書くだけ
   ※応用は改善時に学習しないと定着不可能のため

---

## 下記自分ルール　これだけくりかえし

1. 選択と集中 選択が出来たところで無意味　意味あるものに集中して有意味　（自問:issue）
2. 理解と説明 理解できたところで無意味　難しいことをカンタンに説明ができる事で有意味 (自己理解:自分の言葉)
3. 施行と改善 施行を続けたところで無意味　施行ありきの改善を続けることで有意味 (自己改善:アップデート)

---
