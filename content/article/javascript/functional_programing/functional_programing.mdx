---
title: "関数型プログラミング"
date: "2021-08-25T22:27:50Z"
updateDate: ""
category: "javascript"
tags: "javascript"
description: "まだ書いていません"
emoji: "🙂"
topImage: ""
---

# はじめに、なぜそうなったのか？から学べばキャッチアップしやすい

- ラムダ計算が始まり
  - 引数として関数を引き取り、その関数をもとに別の関数を返す高階関数という概念が導入された

# 基礎基本を抑える

- 関数型とは

  - JavaScript において関数は第一級オブジェクト
  - 関数はデータとして変数に格納することができる
  - アプリケーション内を自由に行き来できる
  - 上記をもって JavaScript を関数型プログラミングと呼ぶ所以
  - 関数型プログラミングは宣言型プログラミング

- 命令型と宣言型

  - 命令型

    - 従来のプログラミング言語
    - 結果を得るための手順「how(どのようにするのか)」を記述する
    - 実装に関する詳細を説明するように記述するため
      一見しただけでは何をしたいのかが分からない

  - 宣言型
    - 「what(何をするのか)」が重要で、「how(どのようにするのか)」は重要ではない
    - ひらすら「what(何をするのか)」を記述する
    - 実装に関する詳細は、個々の関数により抽象化され隠蔽されているため、
      何をしたいのかが分かり、コードが読みやすい

- 関数型プログラミングの基礎概念
  - 関数型プログラミングではすべてのデータがイミュータブル(変異しない値)
    - アプリケーションのデータはイミュータブルなのでそれ自体は変化しない
    - データに変更を加える時、必ずコピーを作成してから変更する
    - 非破壊的
  - 純粋関数
    - 引数の値のみを参照して、それをもとに計算し値を返す関数
    - 純域関数に副作用はない
    - グローバル関数に値を書き込んだり、アプリケーションの状態を変更したりしない
    - 純粋関数は引数をイミュータブルなデータとして扱う
  - データの変換方法
    - Array.filter
      - 配列から新しい配列として返却する
    - Array.join
      - 配列の全要素を結合する
    - Array.map
      - オブジェクトの配列や関数の配列等、任意の JavaSctipt の値の配列を生成できる
    - Array.reduse , Array.reduseRight
      - 配列から単一の値へ変換する
    - まとめ
      - 上記のデータ変換方法は元となるデータをイミュータブルに保つことができる
      - 要するに、元データは副作用を受けない　元データはオリジナル
      - 上記メゾットはすべて非破壊的
  - 高階関数
    - 高階関数とは他の関数を引数にとるか、戻り値として関数を返すか、
      もしくはそれら両方を満たす関数
      - Array.map , Array.filter , Array.reduce など
      - 戻り値として関数を返す場合、カリー化というテクニックをよく使用する
      - カリー化参考サイト →https://qiita.com/Yametaro/items/99cc1c8ebcfc703b1410
  - 再帰関数
    - 関数に中から自分自身を再帰的に呼び出す関数
      - 関数型プログラミングで多用される
      - ループで書かれたコードは多くの場合再帰関数を使って書き直すことができる
  - 関数の合成
    - ひとつの関数はひとつのタスクのみを受け持つ
    - 最終的にそれらの小さな関数を組み合わせてアプリケーションのロジックを記述する
    - このように関数を順番に、もしくは並行に呼び出したり、幾つかの関数を呼び出し束ねてより大きな関数をつくる
    - 上記を踏まえ、アプリケーションの全体を構築する過程を関数の合成という

# 自分が理解できたドキュメントが必ず存在するから

# その使用したドキュメントを、以下項目に沿って、

# かつ自分が理解したまま自分の言葉で言語化してまとめきる

# 今回の目的　達成したい箇所 ユースケース

# 問題　理解できていない箇所

# 解決策　対策手順の概要

# 前提条件　あれば書く　基本情報や必須条件など

# 目的達成手順　順序立てた目的達成手順

# 上記の原理　なぜそうなるのか

# まとめ　ポジティブ意見

- 関数型プログラミングとは、宣言型のプログラミングであり、
  コードは小さな関数の組み合わせでできている
  ひと目見ただけで、何をするのかがわかり、コード自体が冗長ではない場合がほとんど
  非破壊的にプログラムすることが基本であるため、実現するためのテクニックが幾つかあるが
  基本的な考え方は不変なので、わかりやすい
- バニラ JavaScript のテクニック, 非同期通信, 高階関数ができるようになること

# 自分がわからないと意味がないので自分の言葉でアウトプットすること

# 構成１　外向けの場合

- 目的 結論から宣言する
- 問題と解決策だけを書く
- ユースケースをイメージ出来なければアウト
- 応用（破）は基本（守）を理解してから　基本（守）に混ぜない　応用は改善と同義
- すべて理解、まとめようとすると冗長、肥大化してごちゃごちゃになるので
- 問題と対策は一対一　基本（守）で一対一　応用（破）で一対一
- というふうにひとつの記事に対してひとつの解決
- ひとつのフローに対してひとつの処理の考え方　システム

---

## 構成２　内向けの場合

1. 記事構成（記事構成）
2. 目的（解決したい問題）結論から宣言する
3. 解決策（対策手順の概要）
4. ユースケースのイメージ（ストーリーこれ ② かも）
5. 説明と理由（手順を段階的に）（理由を書くとイメージがさらに UP する）（関連記事へのリンク＝自分用、関連記事への後記＝稼ぎ用）
6. 実習（コード挿入）
7. まとめ　まとめるならポジティブ　まとめないケースもあるマナブさん
8. 稼ぐ要素を必ず添付
9. 応用リンク（⑤ の説明の後記）

---

## ひとつひとつ理解するための大義、フレームワーク

1. 目的と issue 本当に達成すべきか
2. 問題と改善 どのような問題を解決してくれるか
3. 基本の使い方 基本的な使い方だけ書く
4. 応用の使い方 応用して使うにはどのような知識を持っておけば良いかだけ書く
   ※前提として 1,2 のみで大枠だけ書くだけ
   ※応用は改善時に学習しないと定着不可能のため

---

## 下記自分ルール　これだけくりかえし

1. 選択と集中 選択が出来たところで無意味　意味あるものに集中して有意味　（自問:issue）
2. 理解と説明 理解できたところで無意味　難しいことをカンタンに説明ができる事で有意味 (自己理解:自分の言葉)
3. 施行と改善 施行を続けたところで無意味　施行ありきの改善を続けることで有意味 (自己改善:アップデート)

---
