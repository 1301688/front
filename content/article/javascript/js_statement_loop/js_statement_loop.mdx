---
title: "JavaScriptの反復処理"
date: "2021-09-29T05:57:31Z"
updateDate: ""
category: "javascript"
tags: "javascript"
description: "まだ書いていません"
emoji: "🙂"
topImage: ""
---

# はじめに、なぜそうなったのか？から学べばキャッチアップしやすい

- JavaScript は文（statement)と式(expression)から構成されている
  - 文を正しく理解すれば JavaScript の基本も理解できる

# 基礎基本を抑える

## JavaScript のループと反復処理

- プログラミングにおいて同じ処理を繰り返すために同じコードを繰り返し書かないように
- ループやイテレータなどを使い、反復処理として同じ処理を繰り返し実行できる
- for 文などの構文、または配列メゾットを利用して反復処理を行う

- イテレータ
  - 配列やリストのようにデータがいくつか連なっているもの（格納庫）に対して、
  - どの格納庫に対してもすべて同じ方法で、順番にアクセスする方法
- ループ
  - ある条件を満たすまで繰り返すこと

---

## while 文

- while 文は条件式が true であるならば、反復処理を行う

```js
while (条件式) {
  実行する文
}
```

- while 文の実行フロー

1. 条件式 の評価結果が true なら次のステップへ、false なら終了
2. 実行する文を実行
3. ステップ 1 へ戻る

- while サンプルコード

```js
let atai = 0
console.log(`ループ開始前の値：${atai}`)
while (atai < 10) {
  console.log(`ループ中の値：${atai}`)
  atai += 1
}

console.log(`ループ終了後の値：${atai}`)
```

## 無限ループ

- 無限ループが発生する原因のほとんどは条件式に関連する実装ミス
- 条件式の評価結果が常に true などが多い
- 無限ループサンプルコード

```js
let atai = 0
console.log(`ループ開始前の値：${atai}`)
while (atai > 0) {
  // 条件式:変数'atai'が0より大きければtrue = 無限
  console.log(`ループ中の値：${atai}`)
  atai += 1
}

console.log(`ループ終了後の値：${atai}`)
```

## do while 文

- do while 文は while 文はほぼ同じ　実行順序が異なる　必ず最初に実行する文を処理する

```js
do {
  実行する文
} while (条件式)
```

- do while 　文の実行フロー

1. 実行する文を実行
2. 条件式 の評価結果が true なら次のステップへ、false なら終了
3. ステップ 1 へ戻る

- do while 文のサンプルコード

```js
const risounoatai = 100
let genjitunoatai = 0

do {
  console.log(`これが理想の値：${risounoatai}`)
  genjitunoatai += 1
  console.log(`これが現実の値：${genjitunoatai}`)
} while (genjitunoatai < 100)
```

## while 文と do while 文の使用ケースについて

- while 文と do while 文の仕組みをうまく利用し、ループの開始前とループ中の処理をまとめて書くことができる
- しかし、他の書き方で解決できないかを考えてからでも遅くはない

---

## for 文

- for 文は繰り返す範囲を指定した反復処理を書くことができる

```js
for (初期化式; 条件式; 増分式) {
  実行する文
}
```

- for 文の実行フロー

1. 初期化式 で変数の宣言
2. 条件式 の評価結果が true なら次のステップへ、false なら終了
3. 実行する文 を実行
4. 増分式 で変数を更新
5. ステップ 2 へ戻る

- for 文のサンプルコード

```js
for (let i = 10; i > 0; i--) {
  console.log(i)
  if (i === 1) {
    console.log("dokkaaaaaaaan!!")
  }
}
```

## break 文

- break 文は処理中の文から抜けて次の文へ移行する制御文
- while、do-while、for の中で使い、処理中のループを抜けて次の文へ制御を移すことができる

```js
while (true) {
  // 実行する文
  break // *1 へ
}
// *1 次の文
```

- break 文の実行フロー

1. while、do-while、for のいずれかを実行
2. 条件式の評価結果が true なら break
3. break を囲っている反復処理を終了させ次の処理へ

- break 文のサンプルコード

```js
// 引数の`id`が存在すればtrueを返す
function isEven(id) {
  return id === "user_name"
}
// 引数の`idname`に"user_name"が含まれているならtrueを返しbreakする
function isEvenIncluded(idname) {
  let isEvenIncluded = false
  for (let i = 0; i < idname.length; i++) {
    const id = idname[i]
    if (isEven(id)) {
      isEvenIncluded = true
      break
    }
  }
  // breakした後に実行する文
  return isEvenIncluded
}
const ids_array = ["user_name3", "user_name2", "user_name1", "user_name"]
console.log(isEvenIncluded(ids_array)) // => true
```

## return 文（反復処理を終了させるケース）

- return 文は現在の関数を終了させることができる
- break と同様に思われるが、異なる
- break は break を囲っている while 文や for 文の繰り返しが終了し、次の処理を実行するのに対し
- return は関数ごと終了させる

![break&return_image](./break&return_image.jpg)

- return 文の実行フロー

1. 大抵関数を宣言する
2. while、do-while、for のいずれかを実行
3. 条件式の評価結果が true なら return
4. return が含まれる関数全体を終了させて次のブロックへ

- return 文のサンプルコード

```js
// 引数の`id`が存在すればtrueを返す
function isEven(id) {
  return id === "user_name"
}
// 引数の`idname`に"user_name"が含まれているならtrueを返しreturnする
function isEvenIncluded(idname) {
  for (let i = 0; i < idname.length; i++) {
    const id = idname[i]
    if (isEven(id)) {
      return true
    }
  }
  return false
}
const ids_array = ["user_name3", "user_name2", "user_name1", "user_name"]
console.log(isEvenIncluded(ids_array)) // => true
// "user_name"を見つけたらすぐにreturnすることで一時的な変数が不要となり、より簡潔に書ける
```

## continue 文

- continue 文は現在の反復処理を終了して、次の反復処理を行う
- while、do-while、for の中で使うことができる

```js
while (条件式) {
  // 実行される処理
  continue // `条件式` へ
  // これ以降の行は実行されません
}
```

# 自分が理解できたドキュメントが必ず存在するから

# その使用したドキュメントを、以下項目に沿って、

# かつ自分が理解したまま自分の言葉で言語化してまとめきる

# 今回の目的　達成したい箇所 ユースケース

# 問題　理解できていない箇所

# 解決策　対策手順の概要

# 前提条件　あれば書く　基本情報や必須条件など

# 目的達成手順　順序立てた目的達成手順

# 上記の原理　なぜそうなるのか

# まとめ　ポジティブ意見

- 反復処理を実装したい = 構文で実装　または　配列メゾットで実装
  - 双方どちらが優れているというわけでもない
  - プログラミングという観点から考えると、どちらの方法も使いこなせるようになることが重要
  - 構文で実装 = 基本的理解がないと実装できない
  - 配列メゾットで実装 = ユースケースを正しく理解しておかないと実装できない

# 自分がわからないと意味がないので自分の言葉でアウトプットすること

---

## 構成２　内向けの場合

1. 記事構成（記事構成）
2. 目的（解決したい問題）結論から宣言する
3. 解決策（対策手順の概要）
4. ユースケースのイメージ（ストーリーこれ ② かも）
5. 説明と理由（手順を段階的に）（理由を書くとイメージがさらに UP する）（関連記事へのリンク＝自分用、関連記事への後記＝稼ぎ用）
6. 実習（コード挿入）
7. まとめ　まとめるならポジティブ　まとめないケースもあるマナブさん
8. 稼ぐ要素を必ず添付
9. 応用リンク（⑤ の説明の後記）

---

## ひとつひとつ理解するための大義、フレームワーク

1. 目的と issue 本当に達成すべきか
2. 問題と改善 どのような問題を解決してくれるか
3. 基本の使い方 基本的な使い方だけ書く
4. 応用の使い方 応用して使うにはどのような知識を持っておけば良いかだけ書く
   ※前提として 1,2 のみで大枠だけ書くだけ
   ※応用は改善時に学習しないと定着不可能のため

---

## 下記自分ルール　これだけくりかえし

1. 選択と集中 選択が出来たところで無意味　意味あるものに集中して有意味　（自問:issue）
2. 理解と説明 理解できたところで無意味　難しいことをカンタンに説明ができる事で有意味 (自己理解:自分の言葉)
3. 施行と改善 施行を続けたところで無意味　施行ありきの改善を続けることで有意味 (自己改善:アップデート)

---
